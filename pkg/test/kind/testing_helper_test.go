//go:build integration

package kind_test

import (
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

const (
	// kubeconfigPath is the path to the kubeconfig file created by `make test-setup`
	// This is relative to the project root
	kubeconfigPath = ".ignore.kindenv.kubeconfig.yaml"

	// forgeKubeconfigEnvVar is the environment variable set by forge testenv
	// when running integration tests with `forge test integration run`
	forgeKubeconfigEnvVar = "FORGE_METADATA_TESTENV_KIND_KUBECONFIGPATH"
)

// getTestKubeconfig returns the path to the kubeconfig file for the test cluster.
// It checks the following sources in order:
// 1. FORGE_METADATA_TESTENV_KIND_KUBECONFIGPATH - set by forge testenv
// 2. KUBECONFIG - standard kubernetes config env var
// 3. Project kubeconfig at .ignore.kindenv.kubeconfig.yaml (created by `make test-setup`)
//
// If no valid kubeconfig is found, it skips the test with a helpful message.
//
// Note: This function also fixes a forge bug where kubeconfig files generated by
// testenv-kind are missing the current-context field. If detected, it sets the
// current-context to the first available context.
func getTestKubeconfig(t *testing.T) string {
	t.Helper()

	// Priority 1: Forge testenv provides kubeconfig path via environment variable
	if forgeKubeconfig := os.Getenv(forgeKubeconfigEnvVar); forgeKubeconfig != "" {
		if _, err := os.Stat(forgeKubeconfig); err == nil {
			t.Logf("Using kubeconfig from forge testenv: %s", forgeKubeconfig)
			fixKubeconfigCurrentContext(t, forgeKubeconfig)
			return forgeKubeconfig
		}
		t.Logf("Warning: %s is set to %s but file does not exist", forgeKubeconfigEnvVar, forgeKubeconfig)
	}

	// Priority 2: Standard KUBECONFIG environment variable
	if kubeconfig := os.Getenv("KUBECONFIG"); kubeconfig != "" {
		if _, err := os.Stat(kubeconfig); err == nil {
			t.Logf("Using kubeconfig from KUBECONFIG env var: %s", kubeconfig)
			return kubeconfig
		}
		t.Logf("Warning: KUBECONFIG is set to %s but file does not exist", kubeconfig)
	}

	// Priority 3: Project kubeconfig (created by `make test-setup`)
	kubeconfigFullPath := getProjectKubeconfigPath(t)
	if _, err := os.Stat(kubeconfigFullPath); err == nil {
		t.Logf("Using project kubeconfig: %s", kubeconfigFullPath)
		return kubeconfigFullPath
	}

	// No valid kubeconfig found
	t.Skipf("No valid kubeconfig found. Options:\n"+
		"  1. Run 'forge test integration run' (sets %s)\n"+
		"  2. Set KUBECONFIG environment variable\n"+
		"  3. Run 'make test-setup' to create %s",
		forgeKubeconfigEnvVar, kubeconfigFullPath)
	return ""
}

// fixKubeconfigCurrentContext fixes a forge bug where kubeconfig files generated by
// testenv-kind are missing the current-context field. This function reads the kubeconfig,
// and if current-context is empty or missing, it sets it to the first available context.
func fixKubeconfigCurrentContext(t *testing.T, kubeconfigPath string) {
	t.Helper()

	// Read the kubeconfig file
	data, err := os.ReadFile(kubeconfigPath)
	if err != nil {
		t.Logf("Warning: failed to read kubeconfig for current-context fix: %v", err)
		return
	}

	content := string(data)

	// Check if current-context is already set (not empty)
	// Look for 'current-context: ""' or 'current-context:' followed by newline
	emptyContextPattern := regexp.MustCompile(`current-context:\s*(""|'')?\s*\n`)
	hasEmptyContext := emptyContextPattern.MatchString(content)

	// Also check if current-context line doesn't exist at all
	hasCurrentContext := strings.Contains(content, "current-context:")

	if !hasEmptyContext && hasCurrentContext {
		// current-context is already set, nothing to do
		return
	}

	// Extract context name from the contexts section
	// Looking for pattern like:
	//   name: kind-forge-test-integration-...
	contextNamePattern := regexp.MustCompile(`contexts:\s*\n-\s+context:[\s\S]*?name:\s+(\S+)`)
	matches := contextNamePattern.FindStringSubmatch(content)
	if len(matches) < 2 {
		t.Logf("Warning: could not extract context name from kubeconfig")
		return
	}
	contextName := matches[1]

	t.Logf("Fixing kubeconfig: setting current-context to %s", contextName)

	// Fix the kubeconfig
	var newContent string
	if hasEmptyContext {
		// Replace empty current-context with the context name
		newContent = emptyContextPattern.ReplaceAllString(content, "current-context: "+contextName+"\n")
	} else {
		// Add current-context line after 'kind: Config'
		newContent = strings.Replace(content, "kind: Config", "current-context: "+contextName+"\nkind: Config", 1)
	}

	// Write the fixed kubeconfig back
	if err := os.WriteFile(kubeconfigPath, []byte(newContent), 0o600); err != nil {
		t.Logf("Warning: failed to write fixed kubeconfig: %v", err)
		return
	}
}

// getProjectKubeconfigPath returns the path to the project kubeconfig without checking if it exists.
// This is useful for tests that want to check existence themselves.
func getProjectKubeconfigPath(t *testing.T) string {
	t.Helper()

	// Find project root by looking for go.mod
	projectRoot, err := findProjectRoot()
	if err != nil {
		t.Fatalf("Failed to find project root: %v", err)
	}

	return filepath.Join(projectRoot, kubeconfigPath)
}

// findProjectRoot finds the project root by looking for go.mod file
func findProjectRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			// Reached root directory without finding go.mod
			return "", os.ErrNotExist
		}
		dir = parent
	}
}
