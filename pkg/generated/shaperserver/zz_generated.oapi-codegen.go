/*
Copyright 2024 Alexandre Mahdhaoui

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

//go:build go1.22

// Package shaperserver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package shaperserver

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for BuildarchSelector.
const (
	BuildarchSelectorArm32 BuildarchSelector = "arm32"
	BuildarchSelectorArm64 BuildarchSelector = "arm64"
	BuildarchSelectorI386  BuildarchSelector = "i386"
	BuildarchSelectorX8664 BuildarchSelector = "x86_64"
)

// Defines values for GetContentByIDParamsBuildarch.
const (
	GetContentByIDParamsBuildarchArm32 GetContentByIDParamsBuildarch = "arm32"
	GetContentByIDParamsBuildarchArm64 GetContentByIDParamsBuildarch = "arm64"
	GetContentByIDParamsBuildarchI386  GetContentByIDParamsBuildarch = "i386"
	GetContentByIDParamsBuildarchX8664 GetContentByIDParamsBuildarch = "x86_64"
)

// Defines values for GetIPXEBySelectorsParamsBuildarch.
const (
	Arm32 GetIPXEBySelectorsParamsBuildarch = "arm32"
	Arm64 GetIPXEBySelectorsParamsBuildarch = "arm64"
	I386  GetIPXEBySelectorsParamsBuildarch = "i386"
	X8664 GetIPXEBySelectorsParamsBuildarch = "x86_64"
)

// Error defines model for Error.
type Error struct {
	Code    int32  `json:"code"`
	Message string `json:"message"`
}

// UUID defines model for UUID.
type UUID = openapi_types.UUID

// Content Any content, e.g. a butane/ignition or cloud-init manifest.
type Content = string

// IPXE An iPXE manifest.
type IPXE = string

// BuildarchSelector defines model for buildarchSelector.
type BuildarchSelector string

// UuidSelector defines model for uuidSelector.
type UuidSelector = UUID

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N500 defines model for 500.
type N500 = Error

// N503 defines model for 503.
type N503 = Error

// GetContentByIDParams defines parameters for GetContentByID.
type GetContentByIDParams struct {
	Uuid      UuidSelector                  `form:"uuid" json:"uuid"`
	Buildarch GetContentByIDParamsBuildarch `form:"buildarch" json:"buildarch"`
}

// GetContentByIDParamsBuildarch defines parameters for GetContentByID.
type GetContentByIDParamsBuildarch string

// GetIPXEBySelectorsParams defines parameters for GetIPXEBySelectors.
type GetIPXEBySelectorsParams struct {
	Uuid      UuidSelector                      `form:"uuid" json:"uuid"`
	Buildarch GetIPXEBySelectorsParamsBuildarch `form:"buildarch" json:"buildarch"`
}

// GetIPXEBySelectorsParamsBuildarch defines parameters for GetIPXEBySelectors.
type GetIPXEBySelectorsParamsBuildarch string

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieve an iPXE config to chainload to "/ipxe?labels=values"
	// (GET /boot.ipxe)
	GetIPXEBootstrap(w http.ResponseWriter, r *http.Request)
	// Retrieve dynamically a content by its ID.
	// (GET /content/{contentID})
	GetContentByID(w http.ResponseWriter, r *http.Request, contentID UUID, params GetContentByIDParams)
	// Retrieve an iPXE manifest by selectors
	// (GET /ipxe)
	GetIPXEBySelectors(w http.ResponseWriter, r *http.Request, params GetIPXEBySelectorsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetIPXEBootstrap operation middleware
func (siw *ServerInterfaceWrapper) GetIPXEBootstrap(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetIPXEBootstrap(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetContentByID operation middleware
func (siw *ServerInterfaceWrapper) GetContentByID(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "contentID" -------------
	var contentID UUID

	err = runtime.BindStyledParameterWithOptions("simple", "contentID", r.PathValue("contentID"), &contentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "contentID", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContentByIDParams

	// ------------- Required query parameter "uuid" -------------

	if paramValue := r.URL.Query().Get("uuid"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "uuid"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uuid", r.URL.Query(), &params.Uuid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	// ------------- Required query parameter "buildarch" -------------

	if paramValue := r.URL.Query().Get("buildarch"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "buildarch"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "buildarch", r.URL.Query(), &params.Buildarch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "buildarch", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetContentByID(w, r, contentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetIPXEBySelectors operation middleware
func (siw *ServerInterfaceWrapper) GetIPXEBySelectors(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIPXEBySelectorsParams

	// ------------- Required query parameter "uuid" -------------

	if paramValue := r.URL.Query().Get("uuid"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "uuid"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uuid", r.URL.Query(), &params.Uuid)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	// ------------- Required query parameter "buildarch" -------------

	if paramValue := r.URL.Query().Get("buildarch"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "buildarch"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "buildarch", r.URL.Query(), &params.Buildarch)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "buildarch", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetIPXEBySelectors(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       *http.ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m *http.ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m *http.ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/boot.ipxe", wrapper.GetIPXEBootstrap)
	m.HandleFunc("GET "+options.BaseURL+"/content/{contentID}", wrapper.GetContentByID)
	m.HandleFunc("GET "+options.BaseURL+"/ipxe", wrapper.GetIPXEBySelectors)

	return m
}

type N400JSONResponse Error

type N401JSONResponse Error

type N403JSONResponse Error

type N404JSONResponse Error

type N500JSONResponse Error

type N503JSONResponse Error

type ContentTextResponse Content

type IPXETextResponse IPXE

type GetIPXEBootstrapRequestObject struct {
}

type GetIPXEBootstrapResponseObject interface {
	VisitGetIPXEBootstrapResponse(w http.ResponseWriter) error
}

type GetIPXEBootstrap200TextResponse string

func (response GetIPXEBootstrap200TextResponse) VisitGetIPXEBootstrapResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(200)

	_, err := w.Write([]byte(response))
	return err
}

type GetIPXEBootstrap400JSONResponse struct{ N400JSONResponse }

func (response GetIPXEBootstrap400JSONResponse) VisitGetIPXEBootstrapResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBootstrap401JSONResponse struct{ N401JSONResponse }

func (response GetIPXEBootstrap401JSONResponse) VisitGetIPXEBootstrapResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBootstrap403JSONResponse struct{ N403JSONResponse }

func (response GetIPXEBootstrap403JSONResponse) VisitGetIPXEBootstrapResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBootstrap404JSONResponse struct{ N404JSONResponse }

func (response GetIPXEBootstrap404JSONResponse) VisitGetIPXEBootstrapResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBootstrap500JSONResponse struct{ N500JSONResponse }

func (response GetIPXEBootstrap500JSONResponse) VisitGetIPXEBootstrapResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBootstrap503JSONResponse struct{ N503JSONResponse }

func (response GetIPXEBootstrap503JSONResponse) VisitGetIPXEBootstrapResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type GetContentByIDRequestObject struct {
	ContentID UUID `json:"contentID"`
	Params    GetContentByIDParams
}

type GetContentByIDResponseObject interface {
	VisitGetContentByIDResponse(w http.ResponseWriter) error
}

type GetContentByID200TextResponse string

func (response GetContentByID200TextResponse) VisitGetContentByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(200)

	_, err := w.Write([]byte(response))
	return err
}

type GetContentByID400JSONResponse struct{ N400JSONResponse }

func (response GetContentByID400JSONResponse) VisitGetContentByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetContentByID401JSONResponse struct{ N401JSONResponse }

func (response GetContentByID401JSONResponse) VisitGetContentByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetContentByID403JSONResponse struct{ N403JSONResponse }

func (response GetContentByID403JSONResponse) VisitGetContentByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetContentByID404JSONResponse struct{ N404JSONResponse }

func (response GetContentByID404JSONResponse) VisitGetContentByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetContentByID500JSONResponse struct{ N500JSONResponse }

func (response GetContentByID500JSONResponse) VisitGetContentByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetContentByID503JSONResponse struct{ N503JSONResponse }

func (response GetContentByID503JSONResponse) VisitGetContentByIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBySelectorsRequestObject struct {
	Params GetIPXEBySelectorsParams
}

type GetIPXEBySelectorsResponseObject interface {
	VisitGetIPXEBySelectorsResponse(w http.ResponseWriter) error
}

type GetIPXEBySelectors200TextResponse string

func (response GetIPXEBySelectors200TextResponse) VisitGetIPXEBySelectorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(200)

	_, err := w.Write([]byte(response))
	return err
}

type GetIPXEBySelectors400JSONResponse struct{ N400JSONResponse }

func (response GetIPXEBySelectors400JSONResponse) VisitGetIPXEBySelectorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBySelectors401JSONResponse struct{ N401JSONResponse }

func (response GetIPXEBySelectors401JSONResponse) VisitGetIPXEBySelectorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBySelectors403JSONResponse struct{ N403JSONResponse }

func (response GetIPXEBySelectors403JSONResponse) VisitGetIPXEBySelectorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBySelectors404JSONResponse struct{ N404JSONResponse }

func (response GetIPXEBySelectors404JSONResponse) VisitGetIPXEBySelectorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBySelectors500JSONResponse struct{ N500JSONResponse }

func (response GetIPXEBySelectors500JSONResponse) VisitGetIPXEBySelectorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetIPXEBySelectors503JSONResponse struct{ N503JSONResponse }

func (response GetIPXEBySelectors503JSONResponse) VisitGetIPXEBySelectorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Retrieve an iPXE config to chainload to "/ipxe?labels=values"
	// (GET /boot.ipxe)
	GetIPXEBootstrap(ctx context.Context, request GetIPXEBootstrapRequestObject) (GetIPXEBootstrapResponseObject, error)
	// Retrieve dynamically a content by its ID.
	// (GET /content/{contentID})
	GetContentByID(ctx context.Context, request GetContentByIDRequestObject) (GetContentByIDResponseObject, error)
	// Retrieve an iPXE manifest by selectors
	// (GET /ipxe)
	GetIPXEBySelectors(ctx context.Context, request GetIPXEBySelectorsRequestObject) (GetIPXEBySelectorsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetIPXEBootstrap operation middleware
func (sh *strictHandler) GetIPXEBootstrap(w http.ResponseWriter, r *http.Request) {
	var request GetIPXEBootstrapRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetIPXEBootstrap(ctx, request.(GetIPXEBootstrapRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetIPXEBootstrap")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetIPXEBootstrapResponseObject); ok {
		if err := validResponse.VisitGetIPXEBootstrapResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetContentByID operation middleware
func (sh *strictHandler) GetContentByID(w http.ResponseWriter, r *http.Request, contentID UUID, params GetContentByIDParams) {
	var request GetContentByIDRequestObject

	request.ContentID = contentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetContentByID(ctx, request.(GetContentByIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetContentByID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetContentByIDResponseObject); ok {
		if err := validResponse.VisitGetContentByIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetIPXEBySelectors operation middleware
func (sh *strictHandler) GetIPXEBySelectors(w http.ResponseWriter, r *http.Request, params GetIPXEBySelectorsParams) {
	var request GetIPXEBySelectorsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetIPXEBySelectors(ctx, request.(GetIPXEBySelectorsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetIPXEBySelectors")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetIPXEBySelectorsResponseObject); ok {
		if err := validResponse.VisitGetIPXEBySelectorsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
