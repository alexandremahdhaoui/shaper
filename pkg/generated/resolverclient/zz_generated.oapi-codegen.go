/*
Copyright 2024 Alexandre Mahdhaoui

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package resolverclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package resolverclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for Buildarch.
const (
	Arm32 Buildarch = "arm32"
	Arm64 Buildarch = "arm64"
	I386  Buildarch = "i386"
	X8664 Buildarch = "x86_64"
)

// Buildarch defines model for Buildarch.
type Buildarch string

// Error defines model for Error.
type Error struct {
	Code    int32  `json:"code"`
	Message string `json:"message"`
}

// UUID defines model for UUID.
type UUID = openapi_types.UUID

// AnyRoutes defines model for anyRoutes.
type AnyRoutes = string

// BuildarchSelector defines model for buildarchSelector.
type BuildarchSelector = Buildarch

// UuidSelector defines model for uuidSelector.
type UuidSelector = UUID

// N400 defines model for 400.
type N400 = Error

// N401 defines model for 401.
type N401 = Error

// N403 defines model for 403.
type N403 = Error

// N404 defines model for 404.
type N404 = Error

// N500 defines model for 500.
type N500 = Error

// N503 defines model for 503.
type N503 = Error

// ResolveResp defines model for ResolveResp.
type ResolveResp struct {
	Data *string `json:"data,omitempty"`
}

// ResolveParams defines parameters for Resolve.
type ResolveParams struct {
	Uuid      UuidSelector      `form:"uuid" json:"uuid"`
	Buildarch BuildarchSelector `form:"buildarch" json:"buildarch"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Resolve request
	Resolve(ctx context.Context, anyRoutes AnyRoutes, params *ResolveParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Resolve(ctx context.Context, anyRoutes AnyRoutes, params *ResolveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveRequest(c.Server, anyRoutes, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewResolveRequest generates requests for Resolve
func NewResolveRequest(server string, anyRoutes AnyRoutes, params *ResolveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "anyRoutes", runtime.ParamLocationPath, anyRoutes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uuid", runtime.ParamLocationQuery, params.Uuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buildarch", runtime.ParamLocationQuery, params.Buildarch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ResolveWithResponse request
	ResolveWithResponse(ctx context.Context, anyRoutes AnyRoutes, params *ResolveParams, reqEditors ...RequestEditorFn) (*ResolveResponse, error)
}

type ResolveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResolveResp
	JSON400      *N400
	JSON401      *N401
	JSON403      *N403
	JSON404      *N404
	JSON500      *N500
	JSON503      *N503
}

// Status returns HTTPResponse.Status
func (r ResolveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ResolveWithResponse request returning *ResolveResponse
func (c *ClientWithResponses) ResolveWithResponse(ctx context.Context, anyRoutes AnyRoutes, params *ResolveParams, reqEditors ...RequestEditorFn) (*ResolveResponse, error) {
	rsp, err := c.Resolve(ctx, anyRoutes, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResolveResponse(rsp)
}

// ParseResolveResponse parses an HTTP response from a ResolveWithResponse call
func ParseResolveResponse(rsp *http.Response) (*ResolveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResolveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResolveResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/7RWUW/bNhD+K8StT4MsybbspnpLtwwwsA1F0mDDAm+gpbPEViIZknLiBvrvA0nZUmKj",
	"MYz0SZb18e777o539wSZqKXgyI2G9AkkVbRGg8q9Ub69Fo1B95KjzhSThgkOKdxydt8gYTlyw9YMFRFr",
	"YkokUok1qzCEAJgFSmpKCIDTGiEdWAxA4X3DFOaQGtVgADorsaaehTGo7Ol/7y5H/9DRt2X3jEcflj+/",
	"gwDMVlp72ijGC2jbAFYNq3KqsvIGK8yMUNaSo3DfoNr2HPbA73J4p3ANKfwU9QGK/FcdfdxbsI6bhuWv",
	"+bSYs93d3i5+hda6Uqil4NonJIlj+8gEN8iNy5eUFcuoTVH0Rds8PQE+0lpW6JE5QprEcQA1ak0Ly+wj",
	"zYmlhdoERFZINZKsxOwr2YpGEcZlY6A9leqVUkJ5rs/rxbq59m6stSQen8d9POR+y2ljSqHYN8z35KUS",
	"G5Yj2dCK5cQCbIl6y16OfgM9l53jndm1UHX3W5Oaac14QYSNn+PhNU/P0zwdav5NqBXLc+SBTRDJBeHC",
	"kJJukEhUzrPgxAhCswy1JqZkmijUolEZvoHwvX8vKTlPUjKU9LnEXQlivudKHqh22tai4flbpIxoiZlt",
	"VgMn7IWP2XmXavb8Ui247V+0IhrVBhVBy2lfoUZtCS0o46SiBtUbSLvl+Cgxs+Fjx1x7ZdPzlD0rvxtU",
	"G5YhaTjdUFbRVYU/UNcRb6E1e41aVBu8Ri1P0DQYLEpIVIZ1E40a9+/hLOn+EasvmJljxOyk24d815XJ",
	"WonaDUHl+RHkuRSMG2e0U2s99gPEhpw3NaR3wKYXcwjg8WL+3zyBAKiqpxP/nCewPJh5Afi4HejyiXsC",
	"35MgBcaNs9QZsCVS+PzsE3ssCv20uvM2e/zyIEYBuDE1LCEYT6aYzObvR3jxYTUaT/LpiCaz+SiZzOfj",
	"ZPw+ieMYgp5nNyVfMmntKrEWu0zTzGW6m6yXFT5Sniskf9AyL6loGATQqApSKI2ROo2igpmyWYWZqCO6",
	"g9c7dMTkow/G8xR/to2TaZfPy0+LXfPoBsna9nYrs7bThReEkr9wVQrxlXTFqewKVLEMucYhX0mzEskk",
	"jA9oPjw8hNR9DoUqou6sjn5f/HL1583VaBLGYWnqynI1zLgQLz79fXV94BoC2KDSXsg4jMPYnhESOZUM",
	"UpiGcTiFwC1nrmSip/1m1tr3Al2MbVU5vYsc0t2tc+f6NfHu+N3uIVG/9LXBq+Bn29QJ+MO1r12+WJQm",
	"vqcfM7THRcOW4ibbCWcsqF9mXsOOB0vAa9jpYLq+hk0Gc+v72JnnOzuFgwW5rtXUNVXbPv2EkkzwNSvs",
	"TaWFrQDo+h0s27Zt/w8AAP//Box+0FQMAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
