/*
Copyright 2024 Alexandre Mahdhaoui

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by mockery v2.42.0. DO NOT EDIT.

package mockcontroller

import (
	context "context"

	controller "github.com/alexandremahdhaoui/shaper/internal/controller"
	mock "github.com/stretchr/testify/mock"

	types "github.com/alexandremahdhaoui/shaper/internal/types"
)

// MockResolveTransformerMux is an autogenerated mock type for the ResolveTransformerMux type
type MockResolveTransformerMux struct {
	mock.Mock
}

type MockResolveTransformerMux_Expecter struct {
	mock *mock.Mock
}

func (_m *MockResolveTransformerMux) EXPECT() *MockResolveTransformerMux_Expecter {
	return &MockResolveTransformerMux_Expecter{mock: &_m.Mock}
}

// ResolveAndTransform provides a mock function with given fields: ctx, content, selectors
func (_m *MockResolveTransformerMux) ResolveAndTransform(ctx context.Context, content types.Content, selectors types.IPXESelectors) ([]byte, error) {
	ret := _m.Called(ctx, content, selectors)

	if len(ret) == 0 {
		panic("no return value specified for ResolveAndTransform")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.Content, types.IPXESelectors) ([]byte, error)); ok {
		return rf(ctx, content, selectors)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.Content, types.IPXESelectors) []byte); ok {
		r0 = rf(ctx, content, selectors)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.Content, types.IPXESelectors) error); ok {
		r1 = rf(ctx, content, selectors)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockResolveTransformerMux_ResolveAndTransform_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResolveAndTransform'
type MockResolveTransformerMux_ResolveAndTransform_Call struct {
	*mock.Call
}

// ResolveAndTransform is a helper method to define mock.On call
//   - ctx context.Context
//   - content types.Content
//   - selectors types.IPXESelectors
func (_e *MockResolveTransformerMux_Expecter) ResolveAndTransform(ctx interface{}, content interface{}, selectors interface{}) *MockResolveTransformerMux_ResolveAndTransform_Call {
	return &MockResolveTransformerMux_ResolveAndTransform_Call{Call: _e.mock.On("ResolveAndTransform", ctx, content, selectors)}
}

func (_c *MockResolveTransformerMux_ResolveAndTransform_Call) Run(run func(ctx context.Context, content types.Content, selectors types.IPXESelectors)) *MockResolveTransformerMux_ResolveAndTransform_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Content), args[2].(types.IPXESelectors))
	})
	return _c
}

func (_c *MockResolveTransformerMux_ResolveAndTransform_Call) Return(_a0 []byte, _a1 error) *MockResolveTransformerMux_ResolveAndTransform_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockResolveTransformerMux_ResolveAndTransform_Call) RunAndReturn(run func(context.Context, types.Content, types.IPXESelectors) ([]byte, error)) *MockResolveTransformerMux_ResolveAndTransform_Call {
	_c.Call.Return(run)
	return _c
}

// ResolveAndTransformBatch provides a mock function with given fields: ctx, batch, selectors, options
func (_m *MockResolveTransformerMux) ResolveAndTransformBatch(ctx context.Context, batch map[string]types.Content, selectors types.IPXESelectors, options ...controller.ResolveTransformBatchOption) (map[string][]byte, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, batch, selectors)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResolveAndTransformBatch")
	}

	var r0 map[string][]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[string]types.Content, types.IPXESelectors, ...controller.ResolveTransformBatchOption) (map[string][]byte, error)); ok {
		return rf(ctx, batch, selectors, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[string]types.Content, types.IPXESelectors, ...controller.ResolveTransformBatchOption) map[string][]byte); ok {
		r0 = rf(ctx, batch, selectors, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[string]types.Content, types.IPXESelectors, ...controller.ResolveTransformBatchOption) error); ok {
		r1 = rf(ctx, batch, selectors, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockResolveTransformerMux_ResolveAndTransformBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResolveAndTransformBatch'
type MockResolveTransformerMux_ResolveAndTransformBatch_Call struct {
	*mock.Call
}

// ResolveAndTransformBatch is a helper method to define mock.On call
//   - ctx context.Context
//   - batch map[string]types.Content
//   - selectors types.IPXESelectors
//   - options ...controller.ResolveTransformBatchOption
func (_e *MockResolveTransformerMux_Expecter) ResolveAndTransformBatch(ctx interface{}, batch interface{}, selectors interface{}, options ...interface{}) *MockResolveTransformerMux_ResolveAndTransformBatch_Call {
	return &MockResolveTransformerMux_ResolveAndTransformBatch_Call{Call: _e.mock.On("ResolveAndTransformBatch",
		append([]interface{}{ctx, batch, selectors}, options...)...)}
}

func (_c *MockResolveTransformerMux_ResolveAndTransformBatch_Call) Run(run func(ctx context.Context, batch map[string]types.Content, selectors types.IPXESelectors, options ...controller.ResolveTransformBatchOption)) *MockResolveTransformerMux_ResolveAndTransformBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]controller.ResolveTransformBatchOption, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(controller.ResolveTransformBatchOption)
			}
		}
		run(args[0].(context.Context), args[1].(map[string]types.Content), args[2].(types.IPXESelectors), variadicArgs...)
	})
	return _c
}

func (_c *MockResolveTransformerMux_ResolveAndTransformBatch_Call) Return(_a0 map[string][]byte, _a1 error) *MockResolveTransformerMux_ResolveAndTransformBatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockResolveTransformerMux_ResolveAndTransformBatch_Call) RunAndReturn(run func(context.Context, map[string]types.Content, types.IPXESelectors, ...controller.ResolveTransformBatchOption) (map[string][]byte, error)) *MockResolveTransformerMux_ResolveAndTransformBatch_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockResolveTransformerMux creates a new instance of MockResolveTransformerMux. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockResolveTransformerMux(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockResolveTransformerMux {
	mock := &MockResolveTransformerMux{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
